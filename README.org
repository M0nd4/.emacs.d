#+TITLE: Manu's Emacs Configuration
#+AUTHOR: Manu Goyal
#+EMAIL: manu.goyal2013@gmail.com
#+OPTIONS: num:nil ^:nil

* General
  Here we have general editing and system settings.
** Bind Key
   We use the bind-key package, which provides useful functions for
   creating personal keybindings
   #+begin_src emacs-lisp
     (use-package bind-key
       :ensure t)
   #+end_src
** Shell Environment variables
   We use the exec-path-from-shell package to grab some environment variable
   definitions from the shell environment.
   #+begin_src emacs-lisp
     (use-package exec-path-from-shell
       :ensure t
       :config
       (if (not (eq system-type 'windows-nt))
           (progn
             (if (not (string= "" (exec-path-from-shell-getenv "TMPDIR")))
                 (add-to-list 'exec-path-from-shell-variables "TMPDIR"))
             (exec-path-from-shell-initialize)
             )
         )
       )
   #+end_src
** Revert buffer
   We re-bind the revert-buffer command, which is originally on super-u, which
   is inconvenient for Mac.
   #+begin_src emacs-lisp
     (bind-key "M-U" 'revert-buffer)
   #+end_src
** CEDET
   We configure CEDET, a suite of semantic analysis and development tools for
   emacs.
   #+begin_src emacs-lisp
     (use-package semantic
       :init
       (semantic-mode t)
       )
     (use-package ede
       :init
       (global-ede-mode t)
       )
   #+end_src
** TRAMP
   We configure TRAMP, a package that provides transparent remote file access
   over various protocols.
   #+begin_src emacs-lisp
     (use-package tramp
       :ensure t
       :init
       ;; Tramp saves backups to the local directory, for speed.
       (setq tramp-auto-save-directory "\"/tmp\"")
       )
   #+end_src
** Company mode
   Company is a generic auto-completion framework. It allows you to
   define backends that source completions from different sources, so
   you can have language-specific completions
   #+begin_src emacs-lisp
     (use-package company
       :ensure t
       :init
       (add-hook 'prog-mode-hook 'company-mode))
   #+end_src
** Real-Time Syntax Checking
   We use flycheck to check syntax and style in code. flycheck will
   run language-specific code checkers based on the file type and
   highlight problems.
   #+begin_src emacs-lisp
     (use-package flycheck
       :ensure t
       :init
       (progn
         (add-hook 'prog-mode-hook 'flycheck-mode)    
         ;; Set the standard library to libc++ so that C++11 headers will work
         (setq flycheck-clang-standard-library "libc++")
         ;; Set the flake8rc location for the flake8 checker
         (setq flycheck-flake8rc "~/.config/flake8")
         )
       )
   #+end_src
** Mac OSX Key Bindings
   We set the alt, command, and super modifiers to meta.
   #+begin_src emacs-lisp
     (setq ns-alternate-modifier 'meta)
     (setq ns-command-modifier 'meta)
     (setq x-super-keysym 'meta)
   #+end_src
** File Backups
   We store backups in a temporary folder.
   #+begin_src emacs-lisp
     (setq backup-directory-alist
           `((".*" . ,temporary-file-directory)))
     (setq tramp-backup-directory-alist
           `((".*" . ,temporary-file-directory)))
     (setq auto-save-file-name-transforms
           `((".*" ,temporary-file-directory t)))
   #+end_src
** File Position Persistence
   We save the cursor position at visited files in between sessions.
   #+begin_src emacs-lisp
     (use-package saveplace
       :ensure t
       :init
       (progn
         (setq-default save-place t)
         (setq save-place-file "~/.emacs.d/.saved-places")
         )
       )
   #+end_src
** camelCase Navigation
   We want to navigate camelCase words as separate words.
   #+begin_src emacs-lisp
     (use-package subword
       :diminish subword-mode
       :init
       (global-subword-mode)
     )
   #+end_src
** Parentheses
   Most of the automatic parentheses management libraries in emacs are either
   overkill or buggy, so we just add a bare minimum few key-bindings and
   settings
   #+begin_src emacs-lisp
     ;; Add a key-binding to delete matching pairs
     (bind-key "M-D" 'delete-pair)
     ;; Show matching parentheses
     (add-hook 'prog-mode-hook 'show-paren-mode)
   #+end_src
** Jumping Around Buffers
   We use ace-jump mode, which highlights all occurences of a
   character you enter in the current buffer and lets you immediately
   jump to the place you want.
   #+begin_src emacs-lisp
     (use-package ace-jump-mode
       :ensure t
       :demand
       :bind ("C-c c" . ace-jump-char-mode))
   #+end_src
** Multiple Cursors
   We use the multiple-cursors package, which provides multiple cursors editing
   similar to what you would find in SublimeText.
   #+begin_src emacs-lisp
     (use-package multiple-cursors
       :ensure t
       :bind (("C-S-C C-S-C" . mc/edit-lines)
              ("C->" . mc/mark-next-like-this)
              ("C-<" . mc/mark-previous-like-this)
              ("C-=" . mc/mark-all-like-this-dwim))
       )
   #+end_src
** Completion in an ELISP Minibffer
   #+begin_src emacs-lisp
     (bind-key "TAB" 'completion-at-point read-expression-map)
   #+end_src
** Spell Checking
   We use flyspell.
   #+begin_src emacs-lisp
     (use-package flyspell
       :ensure t
       :defer t
       :init
       (progn
         (add-hook 'prog-mode-hook 'flyspell-prog-mode)
         (add-hook 'text-mode-hook 'flyspell-mode)
         )
       :config
       ;; Sets flyspell correction to use two-finger mouse click
       (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word)
       )
   #+end_src
** Color Scheme
   #+begin_src emacs-lisp
     (use-package zenburn-theme
       :ensure t
       :init
       (load-theme 'zenburn)
       )
   #+end_src
** Opening URLs
   In order to open URLs in the correct external browser, we set the browser
   program based on which executable exists (for now, we support mac's "open"
   and gnome's "gnome-open").
   #+begin_src emacs-lisp
     (setq browse-url-generic-program
           (cond
            ((string= system-type "gnu/linux") "gnome-open")
            (t "open")
            )
           )
     ;; The function to open a url should use the generic program
     (setq browse-url-browser-function 'browse-url-generic)
   #+end_src
** File Management
   We configure dired, the emacs file manager.
   #+begin_src emacs-lisp
     (use-package dired+
       :ensure t
       :commands dired
       :config
       )
     ;; Running dired-omit mode should hide all dotfiles
     (setq dired-omit-files "^\\..*$")
     ;; Never prompt for recursive copies of a directory
     (setq dired-recursive-copies 'always)
     ;; Never prompt for recursive deletes of a directory
     (setq dired-recursive-deletes 'always)
   #+end_src
** Window and Frame Navigation
   We define keybindings for navigating to different windows and frames. We copy
   the windmove-default-keybindings and framemove-default-keybindings functions
   and modify them to use my-keys-minor-mode-map.
   #+begin_src emacs-lisp
     (use-package windmove
       :ensure t
       :bind (("S-<left>" . windmove-left)
              ("S-<right>" . windmove-right)
              ("S-<up>" . windmove-up)
              ("S-<down>" . windmove-down)
              )
       )

     (use-package framemove
       :ensure t
       :bind (("C-S-<left>" . fm-left-frame)
              ("C-S-<right>" . fm-right-frame)
              ("C-S-<up>" . fm-up-frame)
              ("C-S-<down>" . fm-down-frame)
              )
       )
   #+end_src
** UTF-8 Encoding
   We set everything to UTF-8 encoding.
   #+begin_src emacs-lisp
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)
     (setq current-language-environment "UTF-8")
     (prefer-coding-system 'utf-8)
     (setenv "LC_CTYPE" "UTF-8")
   #+end_src
** Fill Column
   We set the fill column to a reasonable default.
   #+begin_src emacs-lisp
     (setq-default fill-column 80)
   #+end_src
** Blinking Cursor
   We don't want the cursor to blink.
   #+begin_src emacs-lisp
     (blink-cursor-mode -1)
   #+end_src
** Column numbers
   We want to see the column number we're at on each line.
   #+begin_src emacs-lisp
     (setq column-number-mode t)
   #+end_src
** Undo/Redo
   By default, emacs doesn't have an actual redo function. The way you redo an
   edit is by undoing a previous undo. This can quickly get confusing when
   you're not exactly sure how much you want to undo or redo, so we use undo
   tree, which provides an actual redo function for emacs and maintains all edit
   history by keeping a tree of undos and redos.
   #+begin_src emacs-lisp
     (use-package undo-tree
       :ensure t
       :diminish undo-tree-mode
       :init
       (global-undo-tree-mode)
       )
   #+end_src
** Turn off All Menus and Tool Bars and Whizbangs
   We don't need that stuff.
   #+begin_src emacs-lisp
     (setq inhibit-startup-screen t)
     (menu-bar-mode -1)
     (scroll-bar-mode -1)
     (tool-bar-mode -1)
   #+end_src
** No Tabs
   We disable indenting with tabs.
   #+begin_src emacs-lisp
     (setq-default indent-tabs-mode nil)
   #+end_src
** Navigating sentences
   We put one space after sentences, so we want emacs to recognize these
   sentences for navigation and editing.
   #+begin_src emacs-lisp
     (setq sentence-end-double-space nil)
   #+end_src
** Font
   We use a variable-width font if we're in buffers with human language.
   #+begin_src emacs-lisp
     (add-hook 'text-mode-hook 'variable-pitch-mode)
   #+end_src
** Case-sensitivity in searches
   By default, we want case sensitivity in searches and replaces to be smart.
   That is, if your search doesn't use capital letters, emacs will ignore case.
   If it does, emacs will be case-sensitive.
   #+begin_src emacs-lisp
     (setq-default case-fold-search t)
   #+end_src
** Whitespace mode
   Turn on whitespace mode, which helps track down and clean up bad
   whitespace in code. Additional settings for whitespace mode can be
   found in custom.el.
   #+begin_src emacs-lisp
     (use-package whitespace
       :ensure t
       :diminish whitespace-mode
       :init
       (progn
         ;; We need to run whitespace-mode after processing file-local and dir-local
         ;; variables
         (add-hook 'hack-local-variables-hook 'whitespace-mode)
         )
       )
   #+end_src
** Recentf
   Enable recentf mode, which keeps track of the files most recently visited
   #+begin_src emacs-lisp
     (use-package recentf
       :config
       (progn
         (recentf-mode 1)
         (setq recentf-max-menu-items 25)
         ))
   #+end_src
** Git
   We use magit, the best git wrapper ever
   #+begin_src emacs-lisp
     (use-package magit
       :ensure t
       :init
       (setq magit-last-seen-setup-instructions "1.4.0")
       )
   #+end_src
** Minibuffer completion
   We use ido to complete wherever possible.
   #+begin_src emacs-lisp
     (use-package ido
       :ensure t
       :config
       (progn
         (ido-mode 1)
         (ido-everywhere 1)
         (setq ido-use-faces nil)
         (setq ido-auto-merge-work-directories-length -1)
         )
       )
     ;; flx-ido provides better completion than regular
     (use-package flx-ido
       :ensure t
       :config
       (flx-ido-mode 1)
       )
     ;; ido-ubiquitous provides ido completion for all minibuffer stuff
     (use-package ido-ubiquitous
       :ensure t
       :config
       (ido-ubiquitous-mode 1)
       )
     ;; smex provides ido completion in functions
     (use-package smex
       :ensure t
       :config
       (progn
         (global-set-key (kbd "M-x") 'smex)
         (global-set-key (kbd "M-X") 'smex-major-mode-commands)
         ;; This is the old M-x.
         (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
         )
       )
   #+end_src
** Buffer menu
   We use ibuffer, which is better than the default buffer menu
   #+begin_src emacs-lisp
     (bind-key "C-x C-b" 'ibuffer)
   #+end_src
* Languages
  Here we have language-specific settings.
** Python
   #+begin_src emacs-lisp
     (use-package anaconda-mode
       :ensure t
       :config
       (progn
         (add-hook 'python-mode-hook 'anaconda-mode)
         (add-hook 'python-mode-hook 'eldoc-mode)
         )
       )

     (use-package company-anaconda
       :ensure t
       :config
       (add-to-list 'company-backends 'company-anaconda))

     ;; Sets the python interpreter to be ipython. To trick emacs into
     ;; thinking we're still running regular python, we run ipython in
     ;; classic mode.
     (setq
      python-shell-interpreter "ipython"
      python-shell-interpreter-args "-i --classic")
   #+end_src
** Go
   #+begin_src emacs-lisp
     (use-package go-mode
       :ensure t
       :mode "\\.go"
       :config
       (exec-path-from-shell-copy-env "GOPATH")
       )
     (use-package company-go
       :ensure t
       :config
       (add-to-list 'company-backends 'company-go)
       )
   #+end_src
** SQL
   #+begin_src emacs-lisp
     (use-package sql
       :ensure t
       :mode ("\\.sql" . sql-mode)
       )
     (setq sql-mysql-login-params (quote (user server port password)))
   #+end_src
** HTML/XML/Javascript
   #+begin_src emacs-lisp
     (use-package js2-mode
       :ensure t
       :mode "\\.js"
       )
     (use-package web-mode
       :ensure t
       :mode "\\.jsx"
       :config
       (progn
         (setq web-mode-enable-auto-quoting nil)
         )
       )
   #+end_src
** OCaml
    #+begin_src emacs-lisp
      (use-package tuareg
        :ensure t
        :mode "\\.ml"
        :config
        (if (file-exists-p (expand-file-name "~/.opam"))
            (progn
              ;; Get the necessary environment variable definitions
              (exec-path-from-shell-copy-env "OCAML_TOPLEVEL_PATH")
              ;; Add the .opam site-lisp directory to the load path
              (push (concat
                     (getenv "OCAML_TOPLEVEL_PATH")
                     "/../../share/emacs/site-lisp")
                    load-path)
              ;; utop
              (use-package utop
                :ensure t
                :mode "\\.ml"
                )
              (autoload 'utop-setup-ocaml-buffer "utop" "Toplevel for OCaml" t)
              (add-hook 'tuareg-mode-hook 'utop-setup-ocaml-buffer)
              (setq utop-command "opam config exec \"utop -emacs\"")
              ))
        )
    #+end_src
** CSS
   #+begin_src emacs-lisp
     (use-package rainbow-mode
       :ensure t
       :init
       (add-hook 'css-mode-hook 'rainbow-mode)
       )
   #+end_src
** LaTeX
   #+begin_src emacs-lisp
     (add-hook 'LaTeX-mode-hook 'visual-line-mode)
     (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
     (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
     (setq reftex-plug-into-AUCTeX t)
     ;; We want to compile to PDFs by default
     (setq TeX-PDF-mode t)
     ;; Use company-auctex
     (use-package company-auctex
       :ensure t
       :config
       (company-auctex-init)
     )
   #+end_src
** Haskell
   #+begin_src emacs-lisp
     (use-package haskell-mode
       :ensure t
       :mode "\\.hs"
       :config
       (progn
         ;; Turn on haskell-mode features automatically
         (add-hook 'haskell-mode-hook 'haskell-indentation-mode)
         (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
         (add-hook 'haskell-mode-hook 'haskell-decl-scan-mode)
         (add-hook 'haskell-mode-hook 'haskell-doc-mode)
         )
       )
   #+end_src
** C/C++
   #+begin_src emacs-lisp
     (use-package company-c-headers
       :ensure t
       :config
       (add-to-list 'company-backends 'company-c-headers))
     (use-package cc-mode
       :config
       (progn
        (bind-key  "M-." 'semantic-ia-fast-jump c-mode-map)
        (bind-key  "M-." 'semantic-ia-fast-jump c++-mode-map)
        (delete 'company-clang company-backends)
        ))
   #+end_src
** Bison
   #+begin_src emacs-lisp
     (use-package bison-mode
       :ensure t
       :mode "\\.y"
       )
   #+end_src
** Scala
   #+begin_src emacs-lisp
     (use-package scala-mode2
       :ensure t
       )

     (use-package ensime
       :ensure t
       :config
       (add-hook 'scala-mode-hook 'ensime-scala-mode-hook))
   #+end_src
** Clojure
   #+begin_src emacs-lisp
     ;; Use the cider package
     (use-package cider
       :ensure t
       )
   #+end_src
